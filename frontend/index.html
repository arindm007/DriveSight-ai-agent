<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DriveSight - Road Risk Assessment</title>
    
    <!-- 1. Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Google Fonts: Roboto (the standard Google font) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- 3. Google Fonts: Material Symbols (for icons) -->
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />

    <style>
        /* Apply the Roboto font as the default */
        body {
            font-family: 'Roboto', sans-serif;
        }
        
        /* This is the standard class for using Material Symbols */
        .material-symbols-outlined {
            font-variation-settings:
            'FILL' 0,
            'wght' 400,
            'GRAD' 0,
            'opsz' 24;
            vertical-align: middle; /* Helps align icons with text */
            line-height: 1; /* Prevents extra line height */
        }
        
        /* Highlight for newest analyzed frame */
        .frame-highlight {
            background: rgba(66,133,244,0.06);
            border-left: 3px solid #4285F4;
            padding-left: 0.5rem;
        }
        /* Progress bar */
        .progress-bar { background: #e6e9eb; height: 8px; border-radius: 8px; position: relative; overflow: hidden; }
        .progress-fill { background: linear-gradient(90deg,#4285F4,#0f9d58); height: 100%; width: 0%; transition: width 0.1s linear; }
        .progress-marker { position: absolute; width: 2px; height: 12px; top: -2px; background: rgba(219,68,55,0.9); }
        .status-badge { display:inline-block; padding:4px 8px; border-radius:999px; font-size:12px; background:#f1f3f4; color:#202124; }
        .status-badge.streaming { background: #e8f0fe; color: #1a73e8; }
        .status-badge.error { background: #fdecea; color: #d93025; }
    </style>

    <!-- Custom Tailwind configuration from the Google UI Demo -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // Google's primary brand colors
                        'google-blue': '#4285F4',
                        'google-red': '#DB4437',
                        'google-yellow': '#F4B400',
                        'google-green': '#0F9D58',
                        // Standard neutral colors used in Google apps
                        'google-gray-light': '#F1F3F4', // Light background
                        'google-gray-medium': '#DADCE0', // Borders
                        'google-gray-dark': '#5F6368',  // Secondary text
                        'google-text': '#202124',       // Primary text
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-google-gray-light text-google-text flex items-center justify-center min-h-screen p-4">

    <!-- Main application card -->
    <div class="bg-white rounded-xl shadow-lg border border-google-gray-medium max-w-2xl w-full overflow-hidden">
        
        <!-- Header -->
        <div class="text-center p-6 border-b border-google-gray-medium">
            <h1 class="text-3xl font-normal text-google-text flex items-center justify-center">
                <span class="material-symbols-outlined text-google-blue mr-2 text-3xl">directions_car</span>
                DriveSight
            </h1>
            <p class="text-base text-google-gray-dark mt-1">AI-powered road risk assessment</p>
        </div>

        <!-- Content -->
        <div class="p-6">
            <div class="upload-section mb-6">
                <!-- Upload Box -->
                <div id="uploadBox" class="border-2 border-dashed border-google-gray-medium bg-google-gray-light rounded-lg p-10 text-center cursor-pointer transition-all hover:border-google-blue hover:bg-blue-50 [&.drag-over]:border-google-green [&.drag-over]:bg-green-50">
                    <span class="material-symbols-outlined text-5xl text-google-blue mb-4">upload_file</span>
                    <div class="text-lg font-medium text-google-text mb-2">Click or drag image/video here</div>
                    <div class="text-sm text-google-gray-dark">PNG, JPEG, WebP, GIF, mp4 up to 20-80MB</div>
                    <input type="file" id="fileInput" class="hidden" accept="image/*,video/*">
                </div>

                <!-- Image Preview -->
                <div class="image-preview text-center" id="preview" style="display: none;">
                    <img id="previewImg" alt="Preview" class="max-w-full max-h-96 rounded-lg border border-google-gray-medium shadow-sm inline-block" style="display: none;">
                    <video id="previewVideo" playsinline muted controls class="max-w-full max-h-96 rounded-lg border border-google-gray-medium shadow-sm inline-block" style="display: none;"></video>
                    <div class="preview-name text-sm text-google-gray-dark mt-2" id="previewName"></div>
                </div>
            </div>

            <!-- Buttons -->
            <div class="button-group flex flex-col sm:flex-row gap-3">
                <!-- Primary Action: Filled Button -->
                <button class="btn-analyze flex-1 bg-google-blue text-white px-6 py-2.5 rounded-full font-medium text-sm hover:bg-blue-700 hover:shadow-md transition-all disabled:opacity-50 disabled:shadow-none disabled:cursor-not-allowed" id="analyzeBtn" disabled>
                    Analyze Video
                </button>
                <!-- Secondary Action: Text Button -->
                <button class="btn-clear sm:flex-none text-google-blue px-4 py-2.5 rounded-full font-medium text-sm hover:bg-blue-50 transition-all" id="clearBtn">
                    Clear
                </button>
            </div>

            <!-- Loading Spinner -->
            <div class="loading text-center p-6 hidden" id="loading">
                <div class="w-10 h-10 border-4 border-google-gray-light border-t-google-blue rounded-full animate-spin mx-auto mb-4"></div>
                <p class="text-sm text-google-gray-dark">Analyzing your image...</p>
            </div>

            <!-- Result Area -->
            <div class="result hidden mt-6" id="result"></div>

            <!-- History Section -->
            <div class="history-section hidden mt-6 border-t border-google-gray-medium pt-6" id="historySection">
                <div class="history-title text-base font-medium text-google-text mb-3 flex items-center">
                    <span class="material-symbols-outlined text-google-gray-dark mr-2">history</span>
                    Recent Analyses
                </div>
                <div id="historyList" class="space-y-2"></div>
            </div>
        </div>
    </div>

    <script>
        // API_BASE remains the same
        const API_BASE = window.location.origin;
        
        // DOM elements remain the same
        const uploadBox = document.getElementById('uploadBox');
        const fileInput = document.getElementById('fileInput');
        const previewDiv = document.getElementById('preview');
        const previewImg = document.getElementById('previewImg');
        const previewName = document.getElementById('previewName');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const loading = document.getElementById('loading');
        const result = document.getElementById('result');
        const historySection = document.getElementById('historySection');
        const historyList = document.getElementById('historyList');

        let selectedFile = null;

        // Drag and drop listeners
        uploadBox.addEventListener('click', () => fileInput.click());
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('drag-over'); // Changed from 'active'
        });
        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('drag-over'); // Changed from 'active'
        });
        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('drag-over'); // Changed from 'active'
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelect();
            }
        });

        fileInput.addEventListener('change', handleFileSelect);

        async function handleFileSelect() {
            const file = fileInput.files[0];
            if (!file) return;
            // Basic validations
            if (!(file.type.startsWith('image/') || file.type.startsWith('video/'))) {
                showError('Please select a valid image or video file');
                return;
            }

            if (file.size > 200 * 1024 * 1024) {
                showError('File is too large (max 200MB)');
                return;
            }

            selectedFile = file;

            // Reset preview
            previewImg.style.display = 'none';
            previewVideo.style.display = 'none';

            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewImg.src = e.target.result;
                    previewName.textContent = file.name;
                    previewDiv.style.display = 'block';
                    uploadBox.style.display = 'none';
                    analyzeBtn.disabled = false;
                    analyzeBtn.textContent = 'Analyze Image';
                    result.style.display = 'none'; // Hide old results
                };
                reader.readAsDataURL(file);
            } else {
                // Video preview using object URL
                // Try to crop to first 5 seconds client-side before rendering
                const MAX_SECONDS = 5;
                previewName.textContent = file.name + ' (preparing preview...)';
                loading.style.display = 'block';
                try {
                    const cropped = await cropVideoToDuration(file, MAX_SECONDS);
                    // Use cropped blob for preview and upload
                    const url = URL.createObjectURL(cropped);
                    previewVideo.src = url;
                    // replace selectedFile with a File created from cropped blob so upload sends trimmed clip
                    selectedFile = new File([cropped], file.name.replace(/\.[^.]+$/, '') + `-preview.webm`, { type: cropped.type });
                    previewName.textContent = file.name + ` (preview ${MAX_SECONDS}s)`;
                } catch (e) {
                    // If cropping fails, fall back to original file preview
                    console.warn('Video cropping failed, using full file', e);
                    const url = URL.createObjectURL(file);
                    previewVideo.src = url;
                    previewName.textContent = file.name;
                } finally {
                    loading.style.display = 'none';
                }

                previewDiv.style.display = 'block';
                uploadBox.style.display = 'none';
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'Analyze Video (stream)';
                result.style.display = 'none';
            }
        }

        // Crop video to given duration (seconds) using MediaRecorder and captureStream.
        // Returns a Blob of the recorded clip (webm) or throws if not supported.
        function cropVideoToDuration(file, maxSeconds) {
            return new Promise((resolve, reject) => {
                if (!('MediaRecorder' in window)) {
                    return reject(new Error('MediaRecorder not supported'));
                }

                const url = URL.createObjectURL(file);
                const tmpVideo = document.createElement('video');
                tmpVideo.muted = true;
                tmpVideo.playsInline = true;
                tmpVideo.src = url;
                tmpVideo.crossOrigin = 'anonymous';

                const chunks = [];
                let recorder;

                const cleanup = () => {
                    try { tmpVideo.pause(); } catch (e) {}
                    tmpVideo.src = '';
                    URL.revokeObjectURL(url);
                };

                tmpVideo.addEventListener('loadedmetadata', async () => {
                    // start playing and recording
                    try {
                        const stream = tmpVideo.captureStream ? tmpVideo.captureStream() : tmpVideo.mozCaptureStream();
                        if (!stream) return reject(new Error('captureStream not supported'));

                        try {
                            recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
                        } catch (e) {
                            try {
                                recorder = new MediaRecorder(stream);
                            } catch (err) {
                                return reject(err);
                            }
                        }

                        recorder.ondataavailable = (ev) => { if (ev.data && ev.data.size) chunks.push(ev.data); };
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, { type: chunks[0]?.type || 'video/webm' });
                            cleanup();
                            resolve(blob);
                        };

                        recorder.start();
                        // Start playback
                        await tmpVideo.play();

                        // Stop after maxSeconds or when video ends
                        const stopTimer = setTimeout(() => {
                            try { recorder.stop(); } catch (e) { cleanup(); reject(e); }
                        }, Math.max(1, Math.floor(maxSeconds * 1000)));

                        tmpVideo.addEventListener('ended', () => {
                            clearTimeout(stopTimer);
                            try { if (recorder.state !== 'inactive') recorder.stop(); } catch (e) { /* ignore */ }
                        });

                    } catch (err) {
                        cleanup();
                        reject(err);
                    }
                });

                tmpVideo.addEventListener('error', (e) => {
                    cleanup();
                    reject(new Error('Failed to load video for cropping'));
                });
            });
        }

        analyzeBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

                loading.style.display = 'block';
                result.style.display = 'none';
                analyzeBtn.disabled = true;
                clearBtn.disabled = true; // Disable clear during analysis

                try {
                    if (selectedFile.type.startsWith('image/')) {
                        const formData = new FormData();
                        formData.append('image', selectedFile);

                        const response = await fetch(`${API_BASE}/analyze`, {
                            method: 'POST',
                            body: formData
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'Analysis failed');
                        }

                        const data = await response.json();
                        displayResult(data);
                        loadHistory();

                    } else {
                        // Video: stream results
                        await analyzeVideoStream(selectedFile);
                    }

                } catch (error) {
                    showError(error.message || String(error));
                } finally {
                    loading.style.display = 'none';
                    analyzeBtn.disabled = false;
                    clearBtn.disabled = false; // Re-enable clear
                }
        });

            async function analyzeVideoStream(file) {
                // Clear previous results
                result.innerHTML = '';
                result.style.display = 'block';

                const fd = new FormData();
                fd.append('video', file);
                // request backend to analyze only first 5 seconds for a preview clip
                const MAX_SECONDS = 5;
                fd.append('max_seconds', String(MAX_SECONDS));

                const response = await fetch(`${API_BASE}/analyze_video`, {
                    method: 'POST',
                    body: fd
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(text || 'Video analysis failed');
                }

                // Arrange playback and analysis side-by-side
                let playbackContainer = document.getElementById('playbackContainer');
                if (!playbackContainer) {
                    playbackContainer = document.createElement('div');
                    playbackContainer.id = 'playbackContainer';
                    playbackContainer.className = 'flex gap-4 items-start w-full';

                    // left: video area (wider)
                    const left = document.createElement('div');
                    left.id = 'playbackLeft';
                    left.className = 'w-2/3 relative';

                    // status and progress container
                    const statusBar = document.createElement('div');
                    statusBar.id = 'statusBar';
                    statusBar.className = 'mb-3 flex items-center justify-between';
                    statusBar.innerHTML = `
                        <div id="streamStatus" class="status-badge">Idle</div>
                        <div>
                            <button id="cancelStreamBtn" class="text-sm text-google-red px-3 py-1 rounded-full bg-red-50 hidden">Cancel</button>
                        </div>
                    `;
                    left.appendChild(statusBar);

                    // progress bar container
                    const progressWrap = document.createElement('div');
                    progressWrap.className = 'mb-3';
                    progressWrap.innerHTML = `<div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>`;
                    left.appendChild(progressWrap);
                    // ensure previewDiv is visible inside left
                    left.appendChild(previewDiv);

                    // overlay marker
                    const marker = document.createElement('div');
                    marker.id = 'videoMarker';
                    marker.style.position = 'absolute';
                    marker.style.top = '0';
                    marker.style.width = '2px';
                    marker.style.height = '100%';
                    marker.style.background = 'rgba(219,68,55,0.9)';
                    marker.style.transition = 'left 0.15s linear';
                    marker.style.left = '0%';
                    marker.style.pointerEvents = 'none';
                    left.appendChild(marker);

                    // right: analysis area (narrower)
                    const right = document.createElement('div');
                    right.id = 'playbackRight';
                    right.className = 'w-1/3 overflow-auto max-h-96';
                    // move current result into right
                    right.appendChild(result);

                    playbackContainer.appendChild(left);
                    playbackContainer.appendChild(right);

                    // insert playbackContainer into the main content area
                    const contentArea = document.querySelector('.p-6');
                    if (contentArea) {
                        contentArea.appendChild(playbackContainer);
                    } else if (historySection && historySection.parentNode) {
                        historySection.parentNode.insertBefore(playbackContainer, historySection);
                    } else {
                        document.body.appendChild(playbackContainer);
                    }
                }

                // Ensure preview elements are visible
                previewDiv.style.display = 'block';
                previewVideo.style.display = 'block';

                // Start playing the preview clip side-by-side while streaming.
                // Many browsers block autoplay unless the video is muted; ensure muted before play.
                previewVideo.muted = true;
                try {
                    previewVideo.currentTime = 0;
                    await previewVideo.play();
                } catch (e) {
                    // autoplay blocked: show a small play overlay so user can start playback
                    let overlay = document.getElementById('playOverlay');
                    if (!overlay) {
                        overlay = document.createElement('div');
                        overlay.id = 'playOverlay';
                        overlay.className = 'absolute inset-0 flex items-center justify-center';
                        overlay.style.pointerEvents = 'auto';
                        const btn = document.createElement('button');
                        btn.className = 'bg-google-blue text-white px-4 py-2 rounded-full';
                        btn.textContent = 'Play Preview';
                        btn.onclick = async () => {
                            try {
                                previewVideo.muted = false; // unmute if desired
                                await previewVideo.play();
                                overlay.remove();
                            } catch (e) {
                                console.error('Play failed', e);
                            }
                        };
                        overlay.appendChild(btn);
                        const left = document.getElementById('playbackLeft');
                        if (left) left.appendChild(overlay);
                    }
                }

                // stop playback after requested seconds
                const stopPlaybackTimer = setTimeout(() => {
                    try { previewVideo.pause(); } catch (e) {}
                }, MAX_SECONDS * 1000 + 200);

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let framesContainer = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    let parts = buffer.split('\n');
                    buffer = parts.pop();

                    for (const part of parts) {
                        if (!part.trim()) continue;
                        try {
                            const obj = JSON.parse(part);
                            if (obj.final) {
                                // final summary
                                const footer = document.createElement('div');
                                footer.className = 'text-xs text-google-gray-dark mt-3';
                                footer.textContent = `Stream completed: ${obj.frames_sent} frames processed in ${obj.processing_time_ms}ms`;
                                result.appendChild(footer);
                                clearTimeout(stopPlaybackTimer);
                            } else {
                                // Per-frame analysis
                                if (!framesContainer) {
                                    // Create container header
                                    const header = document.createElement('div');
                                    header.className = 'bg-white rounded-lg p-5 border border-google-gray-medium mb-3';
                                    header.innerHTML = `<div class="text-base font-medium mb-2">Live Video Analysis</div>`;
                                    framesContainer = document.createElement('div');
                                    framesContainer.id = 'framesList';
                                    header.appendChild(framesContainer);
                                    result.appendChild(header);
                                }

                                const frameDiv = document.createElement('div');
                                frameDiv.className = 'bg-google-gray-light p-2 rounded-lg text-sm text-google-gray-dark mb-2';
                                const a = obj.analysis || {};
                                const score = a.risk_score !== undefined ? a.risk_score.toFixed(1) : 'n/a';
                                const label = a.risk_label || 'UNKNOWN';
                                const summary = a.summary || '';
                                const timeInfo = obj.frame_time_s !== undefined ? ` @ ${obj.frame_time_s}s` : '';
                                frameDiv.innerHTML = `<strong>Frame ${obj.frame_index}${timeInfo}</strong> â€” <span class="font-medium">${label}</span> <span class="text-xs text-google-gray-dark">(${score}/100)</span><div class="text-xs mt-1">${summary}</div>`;
                                frameDiv.id = `frame-${obj.frame_index}`;
                                framesContainer.insertBefore(frameDiv, framesContainer.firstChild);

                                // highlight this frame entry and remove previous highlight
                                const prev = framesContainer.querySelector('.frame-highlight');
                                if (prev) prev.classList.remove('frame-highlight');
                                frameDiv.classList.add('frame-highlight');

                                // move marker to approximate position over video
                                const marker = document.getElementById('videoMarker');
                                if (marker && obj.frame_time_s !== undefined) {
                                    const pct = Math.min(100, Math.max(0, (obj.frame_time_s / MAX_SECONDS) * 100));
                                    marker.style.left = pct + '%';
                                }

                                // Also update a compact top result using latest frame
                                // Reuse displayResult-like compact view for latest frame
                                try {
                                    const latest = obj.analysis || {};
                                    const compact = {
                                        risk_score: latest.risk_score || 0,
                                        risk_label: latest.risk_label || 'UNKNOWN',
                                        summary: latest.summary || '',
                                        detections: latest.detections || {},
                                        processing_time_ms: Math.round((Date.now())/1)
                                    };
                                    // Show compact summary at top
                                    let compactDiv = document.getElementById('videoCompact');
                                    if (!compactDiv) {
                                        compactDiv = document.createElement('div');
                                        compactDiv.id = 'videoCompact';
                                        compactDiv.className = 'mb-3';
                                        result.insertBefore(compactDiv, result.firstChild);
                                    }
                                    compactDiv.innerHTML = `<div class="bg-white rounded-lg p-4 border border-google-gray-medium"><div class="flex justify-between items-center"><div class="text-base font-medium">Live Summary</div><span class="px-3 py-1 text-sm font-medium rounded-full bg-yellow-100">${compact.risk_label}</span></div><div class="text-3xl font-normal text-google-text mt-2">${compact.risk_score}<span class="text-sm text-google-gray-dark">/100</span></div><div class="mt-3 text-sm text-google-gray-dark">${compact.summary}</div></div>`;
                                } catch (e) {
                                    // ignore display errors
                                }
                            }
                        } catch (e) {
                            console.warn('Failed to parse stream chunk', e, part);
                        }
                    }
                }
            }

        clearBtn.addEventListener('click', () => {
            fileInput.value = '';
            selectedFile = null;
            previewDiv.style.display = 'none';
            uploadBox.style.display = 'block';
            analyzeBtn.disabled = true;
            result.style.display = 'none';
        });

        function displayResult(data) {
            let riskClass, riskColorClass;
            switch (data.risk_label.toLowerCase()) {
                case 'high':
                    riskClass = 'bg-red-100 text-google-red';
                    riskColorClass = 'text-google-red';
                    break;
                case 'moderate':
                    riskClass = 'bg-yellow-100 text-yellow-700';
                    riskColorClass = 'text-yellow-700';
                    break;
                case 'low':
                default:
                    riskClass = 'bg-green-100 text-google-green';
                    riskColorClass = 'text-google-green';
            }
            
            const cached = data.cached ? '<span class="ml-2 bg-google-gray-medium text-google-gray-dark text-xs font-medium px-2 py-0.5 rounded-full">CACHED</span>' : '';

            const detections = data.detections || {};
            const objects = detections.detected_objects || [];
            const scene = detections.scene_analysis || {};

            const objectsHtml = objects.length > 0
                ? objects.map(obj => `<span class="inline-block bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-xs font-medium m-0.5">${obj.label} (${(obj.confidence * 100).toFixed(0)}%)</span>`).join('')
                : '<span class="text-sm text-google-gray-dark">No objects detected</span>';

            const html = `
                <div class="bg-white rounded-lg p-5 border border-google-gray-medium">
                    <div class="flex justify-between items-center mb-3">
                        <div class="text-base font-medium text-google-text flex items-center">
                            Analysis Result
                            ${cached}
                        </div>
                        <span class="px-3 py-1 text-sm font-medium rounded-full ${riskClass}">${data.risk_label}</span>
                    </div>
                    
                    <div class="text-5xl font-normal ${riskColorClass} mb-3">${data.risk_score.toFixed(1)}<span class="text-2xl text-google-gray-dark">/100</span></div>
                    
                    <div class="summary bg-google-gray-light p-4 rounded-lg border-l-4 border-google-blue text-sm text-google-text leading-relaxed mb-5">
                        ${data.summary}
                    </div>
                    
                    <div class="details-section mb-5">
                        <div class="details-title text-sm font-medium text-google-gray-dark uppercase tracking-wider mb-2 flex items-center">
                            <span class="material-symbols-outlined text-base mr-1.5">visibility</span> Detected Objects
                        </div>
                        <div class="details-content bg-google-gray-light p-3 rounded-lg">
                            ${objectsHtml}
                        </div>
                    </div>
                    
                    <div class="details-section">
                        <div class="details-title text-sm font-medium text-google-gray-dark uppercase tracking-wider mb-2 flex items-center">
                            <span class="material-symbols-outlined text-base mr-1.5">landscape</span> Scene Analysis
                        </div>
                        <div class="details-content bg-google-gray-light p-3 rounded-lg text-sm text-google-gray-dark space-y-2">
                            <div class="flex justify-between"><strong>Road Type:</strong> <span>${scene.road_type || 'Unknown'}</span></div>
                            <div class="flex justify-between"><strong>Lighting:</strong> <span>${scene.lighting || 'Unknown'}</span></div>
                            <div class="flex justify-between"><strong>Weather:</strong> <span>${scene.weather || 'Unknown'}</span></div>
                            <div class="flex justify-between"><strong>Traffic:</strong> <span>${scene.traffic_density || 'Unknown'}</span></div>
                        </div>
                    </div>
                    
                    <div class="processing-time text-xs text-google-gray-dark text-right mt-4 flex items-center justify-end">
                        <span class="material-symbols-outlined text-sm mr-1">timer</span>
                        Processed in ${data.processing_time_ms}ms
                    </div>
                </div>
            `;

            result.innerHTML = html;
            result.style.display = 'block';
        }

        function showError(message) {
            // Normalize message: if JSON, try to extract useful fields
            let userMessage = '';
            try {
                if (typeof message === 'string' && message.trim().startsWith('{')) {
                    const obj = JSON.parse(message);
                    userMessage = obj.detail || obj.error || obj.message || JSON.stringify(obj);
                } else if (typeof message === 'object' && message !== null) {
                    userMessage = message.detail || message.error || message.message || JSON.stringify(message);
                } else {
                    userMessage = String(message);
                }
            } catch (e) {
                userMessage = String(message);
            }

            // Friendly guidance for common errors
            let guidance = '';
            if (userMessage.toLowerCase().includes('opencv') || userMessage.toLowerCase().includes('libgl')) {
                guidance = '<div class="text-xs text-google-gray-dark mt-2">Server lacks headless OpenCV. Try redeploying with `opencv-python-headless` or install system lib `libgl1`.</div>';
            } else if (userMessage.toLowerCase().includes('api key not valid') || userMessage.toLowerCase().includes('api_key_invalid')) {
                guidance = '<div class="text-xs text-google-gray-dark mt-2">Gemini API key invalid or missing. Set `GEMINI_API_KEY` and restart the server.</div>';
            } else if (userMessage.toLowerCase().includes('default credentials') || userMessage.toLowerCase().includes('application default credentials')) {
                guidance = '<div class="text-xs text-google-gray-dark mt-2">Google credentials missing. Run `gcloud auth application-default login` or set `GOOGLE_APPLICATION_CREDENTIALS`.</div>';
            }

            // Use a Material-style error box
            result.innerHTML = `
                <div class="bg-red-100 border-l-4 border-google-red text-google-red p-4 rounded-lg" role="alert">
                    <div class="flex">
                        <div class="py-1"><span class="material-symbols-outlined mr-3">error</span></div>
                        <div>
                            <p class="font-medium">Analysis Failed</p>
                            <p class="text-sm">${userMessage}</p>
                            ${guidance}
                        </div>
                    </div>
                </div>
            `;
            result.style.display = 'block';
        }

        async function loadHistory() {
            try {
                const response = await fetch(`${API_BASE}/history?limit=5`);
                if (!response.ok) return;

                const data = await response.json();
                if (data.count === 0) {
                    historySection.style.display = 'none';
                    return;
                }

                let html = '';
                for (const analysis of data.analyses.slice(0, 5)) {
                    const time = new Date(analysis.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    let riskColorClass;
                    switch (analysis.risk_label.toLowerCase()) {
                        case 'high': riskColorClass = 'text-google-red'; break;
                        case 'moderate': riskColorClass = 'text-yellow-700'; break;
                        default: riskColorClass = 'text-google-green';
                    }

                    html += `
                        <div class="bg-google-gray-light p-3 rounded-lg text-sm text-google-gray-dark flex justify-between items-center">
                            <div>
                                <strong class_="${riskColorClass}">${analysis.risk_label}</strong>
                                <span class="text-google-text font-medium">(${analysis.risk_score.toFixed(0)})</span>
                            </div>
                            <span class="text-xs">${time}</span>
                        </div>
                    `;
                }

                historyList.innerHTML = html;
                historySection.style.display = 'block';

            } catch (error) {
                console.error('Failed to load history:', error);
            }
        }

        // Load history on page load
        loadHistory();
    </script>
</body>
</html>